package main

import (
	"regexp"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

func main() {

	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

// generateFile generates a _ascii.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_protogin.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-protogin. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P(`import "context"`)
	g.P(`import "github.com/gin-gonic/gin"`)
	g.P(`import "github.com/ozouai/protogin/protogingen"`)
	g.P(`import "github.com/ozouai/protogin"`)
	g.P(`import "github.com/golang/protobuf/jsonpb"`)
	for _, service := range file.Services {
		g.P("type ", service.GoName, "_GinHandler interface {")
		for _, method := range service.Methods {
			g.P(method.GoName, "(context.Context, *", g.QualifiedGoIdent(method.Input.GoIdent), ")", " (*", g.QualifiedGoIdent(method.Output.GoIdent), ", error)")
			g.P(method.GoName, "_Middleware() protogin.MiddlewareList")
		}
		g.P("}")

		g.P("func New", service.GoName, "GinServer(handler ", service.GoName, "_GinHandler, engine *gin.Engine) {")
		for _, method := range service.Methods {
			path := "/" + string(file.Proto.GetPackage()) + "/" + string(service.Desc.Name()) + "/" + string(method.Desc.Name())
			if proto.HasExtension(method.Desc.Options(), annotations.E_Http) {
				ext := proto.GetExtension(method.Desc.Options(), annotations.E_Http)
				opts, ok := ext.(*annotations.HttpRule)
				if !ok {
					panic("Got wrong extension for google http annotation")
				}
				switch pattern := opts.GetPattern().(type) {
				case *annotations.HttpRule_Get:
					generateMethod(g, pattern.Get, method, "GET")
				case *annotations.HttpRule_Post:
					generateMethod(g, pattern.Post, method, "POST")
				case *annotations.HttpRule_Put:
					generateMethod(g, pattern.Put, method, "PUT")
				}

			} else {
				generateMethod(g, path, method, "Any")
			}

		}
		g.P("}")
	}

	return g
}

var pathRegex = regexp.MustCompile("{([^}]+)}")

type parameter struct {
	field  string
	goName string
}

func generateMethod(g *protogen.GeneratedFile, path string, method *protogen.Method, httpMethod string) {
	ginPath := pathRegex.ReplaceAllString(path, ":$1")
	params := []*parameter{}
	for _, param := range pathRegex.FindAllStringSubmatch(path, -1) {
		for _, field := range method.Input.Fields {
			if string(field.Desc.Name()) == param[1] {
				params = append(params, &parameter{field: param[1], goName: field.GoName})
			}
		}
		// g.P(param[1])
	}
	g.P(`engine.`, httpMethod, `("`, ginPath, `", func(ginCtx *gin.Context) {`)
	g.P("var err error")
	g.P("mainCtx := ginCtx.Request.Context()")
	g.P("request := &", g.QualifiedGoIdent(method.Input.GoIdent), "{}")
	g.P("var responseString string")
	if httpMethod == "POST" {
		g.P("err = jsonpb.Unmarshal(ginCtx.Request.Body, request)")
		g.P("if err != nil {")
		g.P("ginCtx.AbortWithError(400, err)")
		g.P("return")
		g.P("}")
	}
	for _, param := range params {
		g.P("request.", param.goName, ` = ginCtx.Param("`, param.field, `")`)
	}
	g.P("err = protogingen.ApplyMiddlewareList(mainCtx, handler.", method.GoName, "_Middleware(), func(ctx context.Context) error {")
	g.P("response, err := handler.", method.GoName, "(ctx, request)")
	g.P("if err != nil { return err }")
	g.P("responseString, err = (&jsonpb.Marshaler{}).MarshalToString(response)")
	g.P("if err != nil { return err }")
	g.P("return nil")
	g.P("})")
	g.P("if err != nil {")
	g.P("ginCtx.AbortWithError(500, err)")
	g.P("return")
	g.P("}")
	g.P("ginCtx.Status(200)")
	g.P("ginCtx.Writer.WriteString(responseString)")
	g.P("})")
}
